
import java.util.Scanner;

/**
 * GameOfLife
 * Demonstrates the game of life multiplying and and dying
 * @author ethanzhou
 *April 24 2017
 */
public class Life {
	static Scanner br = new Scanner(System.in);
	static int[][] field = new int[10][10];
	static int i;
	static int n;
	static boolean k = true;
	public static void main(String[] args){
		do{
		if (n == 0){	
			for(i = 0; i < 10; i++){
				for(n = 0; n < 10; n++){
					System.out.print(field[i][n] = 0);
				}
				System.out.println();
			}
		}else{
			start();
			board();
		}
		}while(k == true);
	}
	
	
	/**
	 * This method gets input from user for which index they want to input a 1 into
	 */
	public static void start(){// making a method void prevents you from needing to return, so you could just call it when you need it to do something
		System.out.println("How many inputs do you want");
		int time = 0;
		int track = br.nextInt();
		do{
		System.out.println("please input coordiantes from 0 - 10");
		field[br.nextInt()][br.nextInt()] = 1;
		time++;
		}while(time < track);
		
	}
	
	
	/**
	 * This method creates the 2-D array that is able to access and keeps going through each index of the array when called.
	 * It calls the rules to update the new 2-D array and then prints it
	 */
	public static void board(){
		for(i = 0; i < 10; i++){
			for(n = 0; n < 10; n++){
				cellCheck(field[i][n]);
				System.out.print(field[i][n]);
					
			}
			System.out.println();
		}
		System.out.println("do you want to move to next gen (true/false)");
		k = br.nextBoolean();
	}
	
	
	/**
	 * this method is the rules for the game of life
	 * @param cell is the index for the 2-D array that is meant for the board
	 * @return returns the new 2-D array that has went threw the rules
	 */
	public static int cellCheck(int cell){
		if (field[i][n] == 1 && field[i][n +1] == 1 && field[i][n-1] ==0 && field[i+1][n] ==0 && field[i-1][n] ==0 || field[i][n] == 1 && field[i][n - 1] == 1 && field[i][n+1] ==0 && field[i+1][n] ==0 && field[i-1][n] ==0 || field[i][n] == 1 && field[i + 1][n] == 1 && field[i][n-1] ==0 && field[i][n+1] ==0 && field[i-1][n] ==0  || field[i][n] == 1 && field[i - 1][n] == 1 && field[i][n-1] ==0 && field[i+1][n] ==0 && field[i][n+1] ==0){
			field[i][n] = 0;
		}else if (field[i][n] == 1 && field[i][n+1] == 1 && field[i][n - 1] ==1 && field[i + 1][n] ==1 && field[i - 1][n] == 1){
			field[i][n] = 0;
		}else if(field[i][n] == 1 && field[i+1 | i-1][n+1 | n-1] == 1 && field[i][n] == 1 && field[i+1 | i-1][n+1 | n-1] == 1 && field[i][n] == 1 && field[i+1 | i-1][n+1 | n-1] == 1 ||  field[i][n] == 1 && field[i+1 | i-1][n+1 | n-1] == 1 && field[i][n] == 1 && field[i+1 | i-1][n+1 | n-1] == 1){
			field[i][n] = 1;
		}else if (field[i][n] == 0){
			if(field[i+1 | i-1][n+1 | n-1] == 1 &&field[i+1 | i-1][n+1 | n-1] == 1 && field[i+1 | i-1][n+1 | n-1] == 1 ){
				field[i][n] = 1;
			}
		}

	
		return field[i][n];
	}
	
}
